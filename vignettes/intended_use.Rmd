---
title: "Intended Use of chevron"
date: "`r Sys.Date()`"
author: Adrian Waddell and Gabriel Becker
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Intended Use of chevron}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


## Introduction 

In this vignette we explain how `chevron` can be used in a study setting to create many TLGs with relatively little
effort. The workflow described in this vignette is a basic one and can be adopted to be more streamlined for a
particular setting.

For this vignette we load the following packages

```{r}
library(chevron)
library(dm)
library(dplyr)
library(rlang)
```

## List of Planned Ouputs (LoPO)

A list of planned outputs (LoPO) contains among other information:

* `tlgfunc`: function that implements the output
* `type`: one of `graph`, `listing`, `table`
* `main_title`: main title
* `subtitles`: additional titles
* `filters`: patient subset definition
* `filename`: file name where the output should be written to 

The information above can be stored in various data structures. For this example we assume the information comes from a
spreadsheet with one row per output. We will use the following LoPO store in the variable `lopo` for the remainder of 
the vignette:

```{r, echo = FALSE}
lopo_entry <- function(tlgfunc, type = c("table", "listing", "graph"), main_title, subtitles, filters, 
                       filename = NULL) {
    type <- match.arg(type)
    
    if (is.null(filename)) {
      ext <- if (type == "grapg") ".pdf" else ".txt"
      filename <- paste0(tlgfunc, "__", paste(filters, collapse = "_"), ext)  
    }
    stopifnot(tools::file_ext(filename) %in% c("txt", "pdf"))
    
    tibble(tlgfunc, type, main_title, subtitles = list(subtitles), filters = list(filters), filename)
}

lopo <- rbind(
  lopo_entry(
    tlgfunc = "dmt01_1", type = "table", main_title = "Demographics and Baseline Characteristics", subtitles = NULL,
    filters = NULL
  ),
  lopo_entry(
    tlgfunc = "dst01_1", type = "table", main_title = "Patient Status at Time of Clinical Cut Off", subtitles = NULL,
    filters = "ITT"
  ),
  lopo_entry(
    tlgfunc = "aet02_1", type = "table", main_title = "Adverse Events", subtitles = NULL,
    filters = NULL
  ),
  lopo_entry(
    tlgfunc = "aet02_1", type = "table", main_title = "Adverse Events", subtitles = NULL,
    filters = "SE"
  ),
  lopo_entry(
    tlgfunc = "aet02_1", type = "table", main_title = "Grade 3-5 Adverse Events", subtitles = NULL,
    filters = c("CTC35", "SE")
  ),
  lopo_entry(
    tlgfunc = "lbt01_1", type = "table", main_title = "Lab Table", subtitles = NULL,
    filters = NULL
  )
)
```


```{r}
knitr::kable(lopo)
```

## Data

From the `lopo` above we know that the *tlg-functions* `dmt01_1`, `aet02_1`, `dst01_1` and `lbt01_1` are used to create
the outputs. `chevron` knows which datasets are required for the particular TLGs


```{r, echo = FALSE}
req_data <- function(id) {c("adsl", "adae", "adlb")}
```

```{r}
req_data(c("dmt01", "aet02_1", "dst01_1", "lbt01_1"))
```

So the `adam_db` object needs to contain the following datasets, we will use the `scda` data:


```{r}
syn_data <- syn_test_data()[c("adsl", "adae", "adlb")]

adam_study_data <- dm(adsl = syn_data$adsl, adae = syn_data$adae, adlb = syn_data$adlb) %>%
  dm_add_pk(adsl, c("USUBJID", "STUDYID")) %>%
  dm_add_fk(adae, c("USUBJID", "STUDYID"), ref_table = "adsl") %>%
  dm_add_pk(adae, c("USUBJID", "STUDYID", "ASTDTM", "AETERM", "AESEQ")) %>%
  dm_add_fk(adlb, c("USUBJID", "STUDYID"), ref_table = "adsl") %>%
  dm_add_pk(adlb, c("STUDYID", "USUBJID", "PARAMCD", "BASETYPE", "AVISITN", "ATPTN", "DTYPE", "ADTM", "LBSEQ", "ASPID"))

adam_study_data
```

## Filters

The `lopo` contains the following filter labels:

```{r}
lopo$filters %>% unlist()
```

Each label corresponds to a particular subsetting operation of a dataset. As there is currently no R package available
that implements filter label based subsetting on `dm` objects we provide a basic approach here:

```{r}
new_filter_func <- function(dataname, expr) {
  e <- enquo(expr)
  d <- enquo(dataname)
  function(x) {
    stopifnot(is_dm(x))
    dm_filter(x, !!d, !!e)
  }
}

# filter label functions
flf <- list(
 ITT = new_filter_func("adsl", ITTFL == "Y"),
 SE = new_filter_func("adsl", SAFFL == "Y"),
 CTC35 = new_filter_func("adae", AETOXGR %in% c("3", "4", "5"))
)
```

These filter label based system can then be used as follows, assume we would like the data for `CTC35_SE`:

```{r}
adam__CTC35_SE <- adam_study_data %>%
  flf$SE() %>%
  flf$CTC35() %>%
  dm_apply_filters()

dm_nrow(adam_study_data)
dm_nrow(adam__CTC35_SE)
```

We now introduce the function `dm_filter_with_labels`

```{r}
get_std_filter_label_defn <- function() flf

dm_filter_with_labels <- function(dm, filter_labels, filter_label_def = get_std_filter_label_defn()) {
  stopifnot(
    is_dm(dm),
    is.null(filter_labels) || all(filter_labels %in% names(filter_label_def))
  )
  
  if (length(filter_labels) == 0)
    return(dm)
  
  Reduce(function(f1, f2) f2(f1), filter_label_def[filter_labels], init = dm)
}

adam_study_data %>%
  dm_filter_with_labels(c("CTC35", "SE"))
```

so to get the filtered data 

```{r}
adam__CTC35_SE <- adam_study_data %>%
  dm_filter_with_labels(c("CTC35", "SE")) %>%
  dm_apply_filters()

adam__CTC35_SE %>%
  dm_nrow()
```

## Templating Title & Footnotes 

The title and footnotes in the `lopo` are not ready for the final output. The final titles usually have the form:

```
{{main_title from lopo}} -- {{population title}}
Protocol: {{protocol}}, Snapshot: {{snapshot}}, Snapshot Date: {{snapshot-date}}, Cutoff Date: {{cutoff-date}}
{{subtitles from lopo}}
```

We now introduce a simple templating framework based on `whiskers`.  Instead of using the `whiskers` R package we define
our own functionality:

```{r}
render_whiskers <- function(templates, dict = character(0)) {
  stopifnot(
    is_character_vector(templates)
  )

  setNames(vapply(templates, render_whiskers_string, character(1), dict = dict), names(templates))
}

render_whiskers_string <- function(template, dict = character(0)) {
  stopifnot(
    is_character_single(template),
    is_fully_named_list(as.list(dict))
  )

  if (length(dict) == 0) return(template)

  ndata <- paste0("{{", names(dict), "}}")
  for (i in seq_along(dict)) {
    template <- gsub(ndata[i], dict[i], template, fixed = TRUE)
  }

  template
}
```


```{r}
titles_template <- list(
  main_title = "{{main_title}} -- {{population title}}", 
  subtitles = c(
    "Protocol: {{protocol}}, Snapshot: {{snapshot}}, Snapshot Date: {{snapshot-date}}, Cutoff Date: {{cutoff-date}}",
    "{{subtitles}}"
  )
)
titles_template

dict <- list(
  
)

```

## Outputs

We now create functions that create the final outputs

```{r}
lopo %>% 
  filter(tlgfunc == "aet02_1")

```






## Summary


